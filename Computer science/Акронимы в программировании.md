# Акронимы в программировании

Наиболее распространённые сокращения терминов.

- [{{ computer science }}](../__tags/computer_science.md)
- [{{ программирование }}](../__tags/programmirovanie.md)
- [{{ акронимы }}](../__tags/akronimy.md)

### DRY

* **Don’t repeat yourself**

Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное
представление в рамках системы. В основном сводится к тому, чтобы хранить
каждую единицу смысла программы в одном экземпляре, так чтобы не требовалось
при внесении правок делать это в нескольких местах. Этот принцип может вредить
т.к. излишнее абстрагирование усложняет понимание кода, при работе нагруженных
систем оказывается проще хранить в других частях системы копию актуальных
данных, вместо постоянного их получения в реальном времени.

### WET

* **Write everything twice**
* **We enjoy typing**

Антоним к DRY, описывает ситуацию, когда одно и то же содержится во многих
местах и при внесении изменений требуется не забыть сделать это в каждом месте.

### KISS

* **keep it short and simple**
* **keep it small and simple**
* **Keep it simple, stupid**

Принцип, запрещающий использование более сложных средств, чем необходимо.

### YAGNI

* **You aren't gonna need it**

Построение системы таким образом, чтобы был реализован весь необходимый
функционал, но не более того. Выступает как предостережение желанию заранее
предусмотреть инструменты на все случаи жизни. Часто оказывается, что время,
потраченное на реализацию таких инструментов оказывается потраченным понапрасну
т.к. эти инструменты в итоге никогда и не понадобятся.

### SOLID

* **single responsibility**

The Single Responsibility Principle - A class should have only one reason to
change (С) Robert C. Martin. Каждый объект должен иметь одну ответственность и
эта ответственность должна быть полностью инкапсулирована в класс. Всё его
поведение должны быть направлено исключительно на обеспечение этой
ответственности. Но надо иметь в виду, что речь идёт не о том, чтобы
класс/метод/функция выполняли одну операцию. Этот принцип про то, что компонент
создан для нужд конкретного заказчика/подразделения/клиента и должен отвечать
только требованиям этого конкретного клиента. Другими словами, нельзя иметь
компоненты, созданные одновременно для нужд бухгалтерии и маркетинга.

* **open-closed**

The Open Closed Principle - программные сущности (классы, модули, функции и т.
п.) должны быть открыты для расширения, но закрыты для изменения. Другими
словами, при написании нового функционала нельзя лезть внутрь старого и
оттестированного.

* **Liskov substitution**

The Liskov Substitution Principle - функции, которые используют базовый тип,
должны иметь возможность использовать подтипы базового типа, не зная об этом.
Другими словами, нельзя сужать возможности подклассов относительно базового
класса, запрещать им что-то, что умеет делать их базовый класс.

* **interface segregation**

The Interface Segregation Principle - программные сущности не должны зависеть
от методов, которые они не используют. Нельзя писать громадные интерфейсы,
которые могут делать всё на свете. Рано или поздно, после внесения изменения в
такой интерфейс, сломается код, который вроде бы не должен зависеть от
изменённого компонента.

* **dependency inversion**

The Dependency Inversion Principle - программные компоненты не должны зависеть
от особенностей реализации. Они должны зависеть от абстракций. Это позволяет
менять реализацию при тех же абстракциях, не ломая поведения системы. Если
по-простому — везде где можно в коде надо ссылаться на интерфейсы, а имена
конкретных имплементаций показывать только в main или подобных местах, нужных
только для запуска системы.

### GRASP

* **General responsibility assignment software patterns**

Фактически это синоним к понятию "паттерны проектирования" или более
официальный вариант наименования.

### ACID

Перечень требований к транзакционной системе (например, к СУБД), обеспечивающие
наиболее надёжную и предсказуемую её работу.

* **Atomicity** — Атомарность.

Транзакция в системе либо проходит полностью, либо не проходит вообще. Нельзя
застрять на середине операции.

* **Consistency** — Согласованность.

Завершённая транзакция никогда не приводит к несогласованному состоянию
системы. В процессе выполнения транзакции несогласованность может появляться,
но она изолируется от других транзакций и не видна им.

* **Isolation** — Изолированность.

Пока транзакция выполняется, на неё не могут повлиять другие транзакции. Равно
как и она не может влиять на них.

* **Durability** — Долговечность.

Однажды выполненная транзакция гарантированно сохраняет изменения. Не может
быть такого, что из-за перезагрузки сервера будут отменены какие то из уже
завершённых транзакций.

### CQRS

Command and Query Responsibility Segregation - разделение запросов (на чтение)
и команд (на запись). При этом подходе мы либо меняем состояние системы, либо
запрашиваем его, но не обе операции одновременно. Это пересекается с советом
делать методы класса либо модифицирующими состояние и ничего не возвращающими
или же только возвращающими состояние. Использование такого подхода может
сделать кодовую базу более понятной и предсказуемой, а также легче
масштабируемой. Но одновременно с этим может стать проблемой при многопоточном
исполнении да и вообще в практике. Например, такой подход порождает ту же
проблему, что и REST. Если запросы на чтение чистые и идемпотентные, то мы не
можем считать статистику посещений или логировать запросы.

Другой каноничный пример, ломающий этот подход - метод **pop** у стека и
подобных структур данных. При его вызове мы одновременно удаляем значение с
вершины стека и возвращаем его.
