# Пузырьковая сортировка

Один из самых простых алгоритмов сортировки, выполняется за O(n^2).

[computer science](./meta_computer_science.md)

[алгоритмы сортировки](./meta_algoritmy_sortirovki.md)


### Основная идея

Мы многократно проходим по массиву и меняем местами соседние значения, если видим, 
что они идут не в правильном порядке. Часто применяется дополнительный флаг,
говорящий что за проход не было сделани ни одной перестановки, следовательно
массив уже отсортирован.

### Реализация на python

```python
from typing import List

unsorted_array = [72, 56, 2, 6, 98, 30, 60, 23, 53, 22, 0, 99, 14]
sorted_array = [0, 2, 6, 14, 22, 23, 30, 53, 56, 60, 72, 98, 99]


def bubble_sort(original_array: List[int]) -> List[int]:
    array = original_array.copy()

    for i in range(len(array)):
        swapped = False

        for j in range(len(array) - 1 - i):
            if array[j + 1] < array[j]:
                array[j + 1], array[j] = array[j], array[j + 1]
                swapped = True

        if not swapped:
            break

    return array


assert bubble_sort(unsorted_array) == sorted_array
```

### На что обратить внимание

1. Сортировка пузырьком устойчива.
1. Во внутреннем цикле счёт идёт от нуля до len - 1 - i. Это связано с тем,
что по мере выполнения скрипта, максимальные значения будут "всплывать" в
конце массива. После первого прохода внешнего цикла мы будем знать, что
последний элемент в массиве это максимальный элемент. После второго прохода
два последних значения уже будут точно отсортированы, после третьего три элемента и т.д.
Поэтому мы постоянно уменьшаем размер окна для внутреннего цикла. Это не обязательно,
но так можно немного уменьшить количество элементов для обработки.  
1. Флаг остановки не обязателен, но позволяет чуть раньше выполнить сортировку 
если массив уже отсортирован или почти отсортирован.
1. В идеальном случае сортировка выполнится за O(n-1).