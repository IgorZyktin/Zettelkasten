# Числа с плавающей запятой

Описание структуры чисел с плавающей запятой по
стандарту [IEEE 754](https://ru.wikipedia.org/wiki/IEEE_754-2008).

- {{ computer science }}
- {{ программирование }}
- {{ математика }}
- {{ IEEE 754 }}
- {{ python }}
- {{ числа с плавающей запятой }}
- {{ вычисления }}
- {{ float }}

## Структура

Число хранится в виде мантиссы и показателя степени, а значение числа
вычисляется по формуле:

    значение = (−1) * знак * мантисса * основание ** степень 

Графически это выглядит так для float32:

```
            ┌─────────────────────────── Знак (1 бит)
            │     ┌───────────────────── Экспонента (8 бит)
            │     │             ┌─────── Мантисса (23 бита)
            │     │             │
            0 00000000 00000000000000000000000
            │                                │
          бит 32                           бит 0
```

Стандартный вид (нормальная форма) числа записывается с мантиссой [1, 10).
Также называется научной нотацией. Есть ещё инженерная нотация, в которой
множители выбираются кратными 3, а мантисса [1, 1000), так удобнее работать с
физическими приставками СИ (применяется в калькуляторах).

Для ЭВМ обычно применяют свою собственную нормализованную форму, в которой
мантиссу приводят к полуинтервалу [1, 2). В этом случае получается неявная
единица в начале мантиссы, которую в данные не сохраняют, но при расчётах
учитывают. Манипуляции с мантиссой осуществляются через подбор степени.

Примечание — оригинальный стандарт тоже содержит термины normal и subnormal, но
там они используются для описания доступной точности для сохранения значения.
Подробнее в разделе про субнормальные числа.

## Бинарный вид в python

Как посмотреть содержимое числа:

```python
import struct

string = ''.join(f'{b:08b}' for b in struct.pack('>f', 177.2568))
print(string)  # '01000011001100010100000110111110'
```

Полученное число можно разложить:

```
               экспонента        мантисса
            0   10000110   01100010100000110111110
```

В десятичной форме:

- Знак +
- Экспонента 10000110 -> 134 - 127 -> 7
  (конверсия для хранения отрицательных степеней)
- Мантисса 01100010100000110111110 -> 1.01100010100000110111110 -> 1.3848187

Результат:

```
-1^0 * 1.3848187 * 2^7 = 177.2567936
```

## Стандартные значения

### Ноль (+0 или -0)

В нормализованной форме нельзя представить ноль, поэтому он записывается особым
значением. Также по стандарту у нуля есть знак.

Запись: знак 0 или 1, все биты экспоненты в 0, все биты мантиссы в 0.

```
               экспонента        мантисса
            0   00000000   00000000000000000000000
            │                                    │
          бит 32                               бит 0
```

### Бесконечность (+∞ или -∞)

Используется при работе с переполнением.

Запись: знак 0 или 1, все биты экспоненты в 1, все биты мантиссы в 0.

```
               экспонента        мантисса
            0   11111111   00000000000000000000000
            │                                    │
          бит 32                               бит 0
```

### Неопределённость (+NaN или -NaN)

Используется при обработке ошибок.

Запись: знак игнорируется, все биты экспоненты в 1, хоть один бит мантиссы 1.

"Тихий NaN" должен иметь первый бит (слева) равным 1.
"Сигнальный NaN" должен иметь первый бит (слева) равным 0 и хоть один из битов
мантиссы равным 1.

```
               экспонента        мантисса
            0   11111111   10000000000000000000000
            │                                    │
          бит 32                               бит 0
```

### Субнормальные числа

В самом стандарте числа делятся на normal и subnormal/denormalized. Не путайте
с нормальной формой записи из математики. При чтении многих статей по
устройству чисел с плавающей запятой эти термины могут запутать.

К normal относятся такие числа, у которых значение экспоненты больше некоторого
стандартного b<sub>min</sub>. Они могут быть записаны с нормальной точностью.
Для них экспонента всегда имеет неявную 1 в начале, например **1.27**.

Субнормальные/денормализованные (subnormal/denormalized) это числа, которые по
величине меньше, чем самое маленькое нормальное число. Для них экспонента
неявно начинается с 0, например **0.27**.

Субнормальные числа меньше нормальных, они находятся в окрестностях нуля и
потенциально могут сильно расширить набор возможных значений. Но их сложно
реализовать, поэтому часто их обработка выполняется программно, а не аппаратно.
Как следствие такие числа обрабатываются медленно и на практике на них часто
просто забивают и приравнивают нулю.

Для этого используются две концепции:

1. Flush To Zero (FTZ) - в качестве результата возвращается нуль, как только
   становится понятно, что результат будет представляться в денормализованном
   виде.
1. Denormals Are Zero (DAZ) - денормализованные числа, поступающие на вход,
   рассматриваются как нули.

### Машинный эпсилон

Минимальное число, которое может быть представлено числом с плавающей запятой
на данной платформе и при этом не равное нулю.

Для него выполняется:

```
1 + ε > 1
```

Пример вычисления машинного эпсилона:

```python
def get_epsilon():
    epsilon = 1.0
    epsilon_last = 0.0
    while 1.0 + epsilon != 1.0:
        epsilon_last = epsilon
        epsilon = epsilon / 2.0
    return epsilon_last


print(get_epsilon())  # 2.220446049250313e-16
```

Не стоит путать его с машинным нулём — числом, которое будет считаться нулём,
даже если его значение отлично от нуля.

### Unit in the last place (Unit of least precision)

Размер шага минимальной точности для числа. При обычной работе с числами с
плавающей запятой такой шаг обычно очень маленький и не мешает в работе. Но по
мере роста значений шаг становится всё больше, и в какой-то момент становится
больше 1.

```python
x = 1.0
p = 0
while x != x + 1:
    x = x * 2
    p = p + 1

print(x)  # 9007199254740992.0
print(p)  # 53
print(x + 2 + 1)  # 9007199254740996.0 - мы прибавили 3, а изменение равно 4 
```

Видно, что в данном случае для числа больше, чем 2<sup>53</sup> погрешность при
работе стала больше 1. При дальнейшем увеличении значения, погрешность будет
увеличиваться ещё больше. Это проявляется как минимально возможный шаг между
двумя возможными значениями числа.

Обычно самый простой способ его увидеть, это увеличивать число х до тех пор,
пока не начнёт выполняться равенство:

```
x == x + 1.0
```

Например, на момент написания этой статьи, unix time в питоне составлял
1619352050.2566361 секунд. Грубое определение следующего доступного значения
вернуло 1619352050.256637 секунд. Из этого следует, что замеры интервалов
времени меньших или равных:

    1619352050.256637 - 1619352050.2566361 = 0.00000095 сек или 0,95 мксек

будут лишены смысла т.к. при этом теряется точность. Именно по этой причине в
python была добавлена возможность замерять время в целых наносекундах, где нет
такой проблемы.

## Литература

1. [Представление чисел с плавающей точкой](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%87%D0%B8%D1%81%D0%B5%D0%BB_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D1%82%D0%BE%D1%87%D0%BA%D0%BE%D0%B9#:~:text=%D0%BD%D0%B5%D0%BB%D1%8C%D0%B7%D1%8F%20%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%BD%D0%BE%3A%20.-,%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%3A,%D0%BF%D0%BE%D0%BB%D1%83%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B2%D0%B0%D0%BB%D0%B5%20%2C%20%D0%B0%20%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BD%D0%B0%20%D0%BF%D0%BE%D0%BB%D1%83%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B2%D0%B0%D0%BB%D0%B5%20.)
1. [IEEE-754-2008](https://irem.univ-reunion.fr/IMG/pdf/ieee-754-2008.pdf)
1. [Онлайн калькулятор](https://www.h-schmidt.net/FloatConverter/IEEE754.html)
