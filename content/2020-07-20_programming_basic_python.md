# Основы языка Python

Перечень базовых сведений о языке.

---

[\#python](./meta_python.md)

## Обзор

Python был создан нидерладским разработчиком Гвидо ван Россумом, опубликован в 1991 году.
Язык высокого уровня, интерпретируемый. Работает на собственной стековой виртуальной
машине, за счёт этого кроссплатформенный. Есть компиляция байт-кода для ускорения повторного
запуска программ, но прирост в скорости не очень большой. Основной код программы исполняется
построчно, по мере продвижения по тексту. Язык сфокусирован на удобстве чтения и использования, 
отличается довольно слабой производительностью. Поддерживает все парадигмы разработки.
Наиболее распространённый вариант интерпретатора CPython написан на языке С. Исполняемый код
также может включать в себя расширения написанные на C.  

Существует в двух основных версиях - Python 2 и Python 3. Здесь рассматривается только третья версия.

## Объектная система

Все сущности языка являются объектами, никаких примитивов не существует. 
Сборка мусора автоматическая, основанная на подсчёте ссылок.
Есть дополнительный инструмент сборки мусора в виде деления объектов на поколения и периодической
проверки наличия у них циклических ссылок. Используется только для объектов контейнерного типа.
Переменных как таковых не существует, вместо них используются имена, ссылающиеся на объекты.
Язык автоматически управляет объектами, в зависимости о того, что пользователь делает с именами.
Передача любых значений всегда производится по ссылке (по указателю), но в зависимости от типа
объекта, поведение может быть различным. Объекты условно разделены на изменяемые (mutable) и 
неизменяемые (immutable). При попытке изменения неизменяемого объекта будет создан новый экземпляр,
к которому перепривяжут старое имя. Старый экземпляр объекта при этом остаётся и его дальнейшая
судьба определяется сборщиком мусора. Из-за такой разницы в поведении иногда способ передачи
аргументов называют call by object, когда одни типы данных в вызовах могут быть мутированы, а другие нет.
К объектам в языке относится всё - примитивные типы, контейнерные типы, классы, функции. Все они
могут передаваться как аргумент, все могут иметь атрибуты и методы, все имеют свой тип данных 
(а также один или несколько предков т.к. язык поддерживает множественное наследование), 
все поддерживают базовый набор операций. Встроенные типы данных, написанные на C, могут иметь 
некоторые ограничения в работе, но все пользовательские типы обладают крайне широким функционалом. 

## Типы данных

Язык строго типизирован, приведение типов происходит в редких случаях (например int <-> float).
Типизация динамическая, проверка производится в рантайме, уже в момент выполнения операций.
Есть возможность проставлять аннотации типов (type hints), они не оказывают никакого влияния 
на работу программы, но используются IDE и инструментами для статической проверки кода (mypy).
В языке нет особой разницы между типом и классом, эти понятия обычно используются как равнозначные.
Тип переменных не указывается, интерпретатор выводит его автоматически. Разрешается постоянно
менять тип переменной путём присваивания ей различных значений.

Стандартная библиотека поддерживает большинство обычных типов данных:
1. None, представляющий собой пустое значение.
1. Целые числа бесконечной размерности (пока не кончится оперативная память).
1. Числа с плавающей запятой, выполнены на базе double, имеют те же проблемы точности.
1. Комплексные числа.
1. Тип decimal, представляющий вещественные числа с высокой точностью.
1. Булевы значения, выполнены на базе целых.
1. Строки. Содержат неограниченное количество символов юникода.
1. Списки - вариация на тему массива, при желании можно использовать настоящие массивы*.
1. Кортежи - неизменяемый аналог списка*.
1. Словари - вариация отображений (map), представлены в нескольких видах. Широко используются
внутри языка для хранения атрибутов объектов.
1. Множества - аналог map с ключами без значений. Удобны для учёта уникальных значений, а также
для характерных операций над множествами (пересечение, исключающее ИЛИ и т.д.).
1. Бинарные типы данных - для операций над сырыми байтами.
1. Более сложные структуры данных - кучи, очереди, двусвязные списки и т.д.
1. Функции - объекты типа FunctionType. Реализуют функции/методы.
1. Классы - объекты типа type или его наследника. Реализуют собственно классы.

* - следует помнить, что словари и кортежи это массивы указателей, которые сами по 
себе не хранят данные. Через это вытекает, что в них может лежать множество ссылок
на один и тот же объект, а также то, что объекты по ссылкам кортежа могут меняться, не может
меняться только перечень ссылок, которые он хранит.

## Базовые операции

Python имеет специфический синтаксис - для разделения уровней вложенности используется
изменение отступа. Стандартно применяется четыре пробела на каждый уровень, хотя
это число можно менять. Это делает код более читаемым, но вызывает проблемы
при публикации кода в HTML, когда разметка нарушает форматирование.

```python
# В языке нет многострочных комментариев

# Присваивание
a = 1
b = 2
c, d = 3, 4  # автоматическая распаковка кортежа, c=3, d=4
a, b = b, a  # обмен значениями, теперь a=2, b=1
x = a, b, c, d  # автоматическое формирование кортежа, x=(2, 1, 3, 4)
*rest, y = x  # распаковка с отбрасыванием, rest=(2, 1, 3), y=4
_, *z = x  # _ это перменная на выброс, z=(1, 3, 4)
a = b = c = 1  # множественное присваивание

del a  # удаление имени "а", не имеет отношения к объекту
del b  # сам объект продолжит существовать, если на него остались ссылки

# Сравнение
a = 2 > 3  # теперь a=True

# Сравнение по цепочке
b = 1 < 2 < 3  # теперь b=True

# Создание списка
_ = [1, 2, 3]

# Распаковка внутри списка, на выходе даст [1, 2, 3, 4, 5, 6]
_ = [1, 2, 3, *[4, 5, 6]]

# Создание словаря, вариант 1
_ = {'a': 1, 'b': 2}

# Создание словаря, вариант 2
_ = dict(a=1, b=1)

# Работа со строками
a = 'hello'
b = 'world'
c = a + ' ' + b  # c='hello world'
c = '{} {}'.format(a, b)
c = '{0} {second}'.format(a, second=b)
c = f'{a} {b}'
```

## Контроль исполнения

В языке нет аналога case, обычно хватает цепочек if-elif.
```python
x = 1
y = 2
z = None
if x > y:
    pass  # пустая инструкция
elif y > x:
    pass
else:
    z = 25
```

## Циклы
В языке есть два типа циклов - for и while. 

While вызывает тело цикла до тех пор, пока предикат возвращает истину.
```python
x = 0
while x != 100:
    x = int(input())  # запросить ввод у пользователя         
    if x > 10:
        # оборвать исполнение цикла
        break       
    else:
        # продолжить с новой итерации, не выполняя код ниже этой команды
        continue
else:
    print('Выполнить эту ветвь кода, если в теле цикла не был вызван break')
``` 

Цикл for работает иначе, он основан на протоколе итерирования. Для работы
ему нужен объект, поддерживающий этот протокол. Большинство стандартных
контейнеров его поддерживают.
```python
x = [1, 2, 3]
for number in x:
    print(number)  # выведет соответственно 1, потом 2, потом 3
    condition = int(input('Введите число'))
    if condition > 10:
        break           
else:
    print('Выполнить эту ветвь кода, если в теле цикла не был вызван break')
```

## Функции

Простые функции:
```python
def some_func(a, b, c, *d, e=None, **f):
    return [a, b, c, d, e, f]

some_func(0, b=1, c=2)

def some_other_func(one, /, two):
    return [one, two]

some_other_func(99, two='test')
```
1. Аргументы a, b, и c это аргументы по позиции, должны идти строго по порядку. 
Все они являются обязательными.
1. Аргумент d соберёт в себя любое дополнительное число аргументов по позиции.
Если передать функции только первые три аргумента, d будет пустым кортежем. При
большем числе элементов, в нём будет кортеж всего, что шло по позиции после a, b и c.
Часто аргумент такого рода называется *args.
1. e это аргумент, передаваемый только по имени. Без указания имени ему нельзя
будет присвоить значение. В данном случае для него есть значение по умолчанию,
поэтому его не обязательно указывать в вызове.
1. Аргумент f соберёт в себя все дополнительные аргументы, которые были переданы в
функцию по имени (кроме e). Представляет собой словарь. Часто назвается **kwargs.
1. Следует помнить, что аргумент по умолчанию вычисляется только один раз, при
создании функции. Не следует без необходимости указывать в качестве аргумента по умолчанию
мутабельные объекты т.к. это может привести к трудно находимым аномалиям в работе.
1. Все функции всегда возвращают значения, по умолчанию None, поэтому return можно не указывать.

```python
# Функция, способная принять какие угодно аргументы
def anything(*args, **kwargs):
    return args, kwargs

anything(0, b=1, c=2)  # вернёт (0, {'b': 1, 'c': 2})

# Функция, обладающая памятью
def is_repeated(val, memory=set()):
    repeated = val in memory
    memory.add(val)
    return repeated

is_repeated(1)  # вернёт False
is_repeated(1)  # вернёт True
```

Функции-генераторы:
```python
def gen():
    yield 1   
    yield 2   
    yield 3     

for each in gen():
    print(each)  # выведет 1, потом 2, потом 3
```
Используются для ленивых вычислений. После вызова сами никакой работы не выполняют,
возвращают объект-генератор. Предполагается, что он потом будет использован в циклах for 
или других способах итерирования.

На каждом вызове происходит продвижение до следующей инструкции yield, 
после чего работа останавливается и контроль выполнения возвращается в вызвавшую функцию.

Можно не только получать значения, но и отправлять их:
```python
def double_number(number):
     while True:
         number *=2 
         number = yield number
 
c = double_number(4)
next(c)  # активация генератора, первый проход до yield, вернёт 8
c.send(5)  # вернёт 10
c.send(176)  # вернёт 352
c.send('A')  # вернёт 'AA'
```

Можно также производить погружение во вложенные генераторы. При этом контроль
за исполнением возвращается на самый верхний уровень, что позволяет управлять
исполнением всех вложенных функций. 
```python
def gen():
    print('A')
    yield 1
    print('B')
    yield 2
    print('C')
    yield 3

def sub_gen():
    print('D')
    yield from gen()
    print('E')
    yield from gen()
    print('F')

for i, each in enumerate(sub_gen()):
    print(i)  # выведет D A 0 B 1 C 2 E A 3 B 4 C 5 F
```
Через этот функционал реализованы корутины и асинхронный код.


Функции также могут быть безымянными:
```python
some = (lambda x, y: x + y)(1, 2)  # вернёт 3
```

Присутвует синтаксис декораторов, который по сути синтаксический сахар.
```python
def x(func):
    return func

@x
def y(something):
    return something * 2

# это эквивалентно
y = x(y)
```
Декоратор может вернуть что угодно вместо оригинальной функции, что позволяет
делать удобную настройку поведения, делая замыкания и заворачивая функции в другие функции.

## Области видимости

Их четыре:
    L - local, локальное окружение.
    E - enclosing, всё, что между локальным и глобальным.
    G - global, глобальное окружение.
    B - builtin, встроенное.
    
Приоритет определения соответственно в порядке LEGB.
```python
print(len)  # это builtin функция
len = 1  # это global переменная, которая заместила встроенную

def func_1():
    global len
    len += 1
    
    x = 2  # это локальная переменная функции func_1 и нелокальная func_2

    def func_2():
        nonlocal x
        x += 1
        y = 10  # это локальная переменная функции func_2
```
1. Всегда можно видеть внешние по отношению к области видимости переменные, но нельзя
их менять, если они специально не указаны для изменения (ключевые слова nonlocal и global).
1. Если переменная ссылается на изменяемый объект, он может быть изменён без указания 
ключевых слов для этого.
1. Всё, чему выполняется присваивание, считается локальным, если заранее об этом не было сказано.

Это может стать проблемой:
```python
x = 1
def func():
    x = 2
    global x
# SyntaxError: name 'x' is assigned to before global declaration
```
    
## Классы

Язык реализует одиночное и множественное наследование, переопределение методов,
атрибуты в форме property.

```python
class A:
    def method(self):
        """Простой метод получает экземпляр класса первым атрибутом.
        """
        print(self)

class B(A):
    pass  # ничего не умеет

class Strange:   
    @classmethod
    def method(cls):
        """Метод класса получает сам класс первым атрибутом. Аналог type(self).
        Разница в том, что этот метод можно вызывать не создав ни одного экземпляра.
        """
        print(cls)

class Weird:   
    @staticmethod
    def method():
        """Статический метод это просто функция в теле класса.
        """
        print('static')

# порядок перечисления базовых классов определяет порядок поиска атрибутов
class Test1(B, Strange, Weird):
    pass

class Test2(Strange, B, Weird):
    pass

class Test3(Weird, Strange, B):
    pass

Test1().method()  # выведет <__main__.Test1 object at 0x0000015FCEBDAFD0>
Test2().method()  # выведет <class '__main__.Test2'>
Test3().method()  # выведет static

class P:
    def __init__(self):
        self._var = 24

    @property
    def var(self):
        """Динамический атрибут, рассчитываемый при запросе.
        """
        return self._var   
    
    @var.setter
    def var(self, value):
        """Присваивает значение динамически, может приверять значение.
        """
        self._var = value

p = P()  # создание экземпляра
print(p.var)  # выведет 24
p.var = 45
print(p.var)  # выведет 45
```

Класс почти полностью определяет поведение объекта, в нём хранятся все методы
и многие из атрибутов. Традиционно, атрибуты для объекта принято проставлять
в методе __init__, который будет автоматически вызван после создания объекта.
Это не конструктор, объект на этот момент уже существует. Ему просто присваиваются атрибуты.
Технически, их можно присваивать где угодно, но вне __init__ это считается плохой практикой.

Методы объекта это функции, лежащие в теле класса.
```python
class A:
    def x(self):
        return 1

    y = lambda self: 2
```

Вызов методов вида:
```python
a = A()
a.x()
a.y()
```

По факту является синтаксическим сахаром к коду:
```python
a = A()
A(a).x()
A(a).y()
```
Язык производит автоматическую подстановку при попытке обратиться к функциям,
расположенным в теле класса. По этой причине не стоит просто так хранить
функции в теле класса т.к. при попытке вызова они будут распознаны в качестве методов.

**Тут надо дописать: _method, __method.**

## Многозадачность

**Тут надо дописать - GIL, threading, multiprocessing, asyncio.**

## Специфические особенности и подводные камни

1. В языке нет констант.
1. Из всех мест откуда видим изменяемый объект, он может быть изменён.
1. Нет private и protected методов, все методы публичные.