# Сортировка подсчётом (counting sort)

Один из самых простых алгоритмов сортировки, выполняется за O(n).

[computer science](./meta_computer_science.md)

[алгоритмы сортировки](./meta_algoritmy_sortirovki.md)


### Основная идея

Мы предполагаем что в массиве есть элементы от 0 до k. Мы собираем массив со
всеми этими числами и записываем в него сколько каждое из них встретилось в исходном массиве.
Потом собираем новый массив, поочерёдно добавляя в него каждое из чисел
повторённое нужное число раз.

### Реализация на python

```python
from typing import List

array = [72, 56, 2, 6, 98, 30, 60, 23, 53, 22, 0, 99, 14]
sorted_array = [0, 2, 6, 14, 22, 23, 30, 53, 56, 60, 72, 98, 99]


def counting_sort(_array: List[int]) -> None:
    # для выполнения вычислений нам надо знать максимальный элемент
    maximum = 0
    for i in range(len(_array)):
        if _array[i] > maximum:
            maximum = _array[i]

    # собираем статистику по частоте каждого элемента в массиве
    statistic = [0] * (maximum + 1)
    for i in range(len(_array)):
        statistic[_array[i]] += 1

    # заполняем массив значениями
    position = 0
    for index, times in enumerate(statistic):
        for i in range(times):
            _array[position + i] = index
        position += times


assert array != sorted_array
counting_sort(array)
assert array == sorted_array
```

### На что обратить внимание

1. Сортировка подсчётом в общем случае неустойчива. Есть вариации, которые 
добавляют устойчивости, но каждая из них требует дополнительных структур данных.
1. Сложность любых вариантов сортировки подсчётом это пройти все n элементов
входного массива, потом пройти k элементов массива со статистикой. В более
сложных вариантах ещё надо пройти по дополнительным массивам для поддержания
устойчивости. Но все эти сложности суммируются, так что формально всё-равно остаётся O(n).  
1. В целом этот алгоритм сортировки довольно странный и похож больше на
алгоритм архивации данных, чем на алгоритм сортировки.
