# Глава 1 - Введение



---

Теги:

- [Книги](../../../_tags/книги.md)
- [Книги по программированию](../../../_tags/книги%20по%20программированию.md)
- [Программирование](../../../_tags/программирование.md)
- [Учебник](../../../_tags/учебник.md)
- [Операционные системы](../../../_tags/операционные%20системы.md)
- [Эндрю Танненбаум](../../../_tags/эндрю%20танненбаум.md)
- [Херберт Бос](../../../_tags/херберт%20бос.md)
- [Конспект](../../../_tags/конспект.md)

---

## Введение

Современный компьютер состоит из одного или нескольких процессоров, оперативной
памяти, дисков, принтера, клавиатуры, мыши, дисплея, сетевых интерфейсов и
других разнообразных устройство ввода-вывода. Получается довольно сложная
система, с которой прикладным программистам не особо удобно работать. Чтобы
упростить им жизнь, существует специальный слой программного обеспечениями,
называемый операционным системами. Именно таким системам и посвящена данная
книга.

Схематичная структура программного обеспечения:

TODO

В общем случае у нас есть аппаратное обеспечение, представленное дисками,
клавиатурой и другими объектами. В слое над аппаратным обеспечением находится
операционная система. Она работает в режиме ядра, имеет полный доступ ко всему
оборудованию и способна запустить исполнение любой инструкции, которую
допускает имеющееся железо. Над ней находятся программы в режиме пользователя -
они ограничены в ресурсах и правах, и управляются операционной системой. Самой
нижней программой пользовательского уровня обычно является оболочка в виде
текстового терминала или графический пользовательский интерфейс с окнами. Они
уже позволяют запускать пользователю другие программы на его усмотрение.

Важное отличие элементов операционной системы от программ пользовательского
уровня заключается в том, что пользователь может по своему усмотрению менять
программы прикладного уровня, но элементы операционной системы он обычно
изменить не может. Зачастую они специально защищены от вмешательств
пользователя на аппаратном уровне. Граница между прикладным программным
обеспечением и операционной системой (далее ОС) не всегда чёткая. Можно
уверенно утверждать, что всё работающее в режиме ядра является элементом ОС. Но
на многих системах часть функций ОС вынесена в пространство пользователя. Эти
компоненты уже не являются столь привилегированными и защищёнными, но они
по-прежнему критически важны для работы компьютера.

Другой особенностью ОС является их долговечность. Современные ОС состоят из
миллионов строк кода и переписывать их каждый раз было бы слишком затратно.
Поэтому они обычно формируют семейства и развиваются на протяжении многих лет.

## 1.1 Что такое операционная система

Если грубо - то, что работает в режиме ядра. Но это не всегда так. Путаница
возникает из-за того, что ОС обычно решает две разные задачи:

1. Дать прикладным программистам удобные прикладные интерфейсы к ресурсам.
2. Организовать взаимодействие с ресурсами, контролировать доступ и приоритет.

### 1.1.1 Операционная система как расширенная машина

Архитектура большинства компьютеров на уровне машинного языка слишком неудобна
для написания прикладных программ. Справочники по интерфейсам устройств,
например стандарт взаимодействия с жёстким диском, может занимать сотни
страниц. Понятно, что никакой современный прикладной программист не захочет
связываться с диском напрямую и предпочтёт вместо этого иметь дело с драйвером
такого диска, предоставленным операционной системой. Но проблема в том, что
зачастую даже такой уровень общения с устройством является слишком
низкоуровневым и на практике нужен ещё один уровень абстракций в виде файла.

Абстракции позволяют бороться со сложностью, делая из одной неподъёмной
проблемы две проблемы адекватного размера.

Проблемы эти:

1. Выделить правильные абстракции и сделать реализацию.
2. Использовать абстракцию для решения проблемы.

В этом плане роль операционной системы - спрятать неоднородные и уродливые
интерфейсы аппаратного обеспечения за удобными и понятными абстракциями,
предоставив более простые и стандартные интерфейсы. С этими абстракциями будут
работать прикладные программисты, а уж они сделают ещё один слой абстракций,
работа с которыми будет удобна для пользователя.

### 1.1.2 Операционная система в качестве менеджера ресурсов

Представление, что ОС нужна для красивых абстракций это взгляд сверху вниз.
Можно ещё посмотреть снизу вверх. В этом случае ОС нужна для контроля доступа,
подсчёта всех имеющихся программных и аппаратных средств, распределения их
между пользователями так, чтобы они друг другу не мешали. Например, если три
пользователя одновременно захотят воспользоваться принтером, ОС должна это
обеспечить таким образом, чтобы не получить перемешанные строчки всех трёх
отправленных документов.

Управление ресурсами со стороны ОС можно разбить на два вида:

- во времени: например центральный процессор. Если у него лишь одно ядро,
  доступ к нему пользователи будут получать по очереди.
- в пространстве: например жёсткий диск или оперативная память. В этом случае
  каждому пользователю можно выделить по кусочку ресурса и пользоваться ими они
  смогут одновременно.

### 1.2 История операционных систем

Операционные системы развивались вместе с компьютерами, на которых работали.
Поэтому имеет смысл в общих чертах знать историю развития компьютеров. Началось
всё с Чарльза Бэббиджа, придумавшего механическую аналитическую машину и
нанявшего первую программистку - Аду Лавлейс.

### 1.2.1 Первое поколение (1945-1955): электронные лампы

Вычислительные машины получили основное развитие в годы Второй мировой войны,
примерно в одно время в разных странах. Часть из них были цифровыми (прим. -
вероятно имеются в виду реле), а часть на радиолампах. По современным меркам
они были весьма примитивно устроены и для выполнения даже простейших операций
тратили многие секунды.

Языков программирования, как и операционных систем тогда не было. Каждый
компьютер обслуживался своей командой инженеров, они разрабатывали его с нуля
без каких либо стандартов. В лучшем случае программирование велось на машинном
языке, в худшем - с использованием монтажных панелей, на которых выполнялась
физическая коммутация проводников. Исполнение программы выглядело как запись
программиста на определённое время, установка монтажной панели и долгое
ожидание расчёта (с надежной, что не выйдет из строя ни одна из 20 000
радиоламп). Изобретение перфокарт упростило ввод программ в компьютер, но суть
осталась той же.

В основном компьютеры применялись для уточнения таблиц синусов/косинусов или
логарифмов, а также для расчёта траекторий артиллерийских снарядов.

### 1.2.2 Второе поколение (1955-1965): транзисторы и системы пакетной сборки

Изобретение транзистора позволило сделать компьютеры надёжными. Появилась
возможность запускать долгие вычисления. Появилось разделение между
проектировщиками, сборщиками, операторами, программистами и обслуживающим
персоналом.

Компьютеры выполнялись в виде мейнфреймов, больших машин в отдельных залах с
кондиционированием воздуха. Программисты приносили свои ящики с перфокартами и
отдавали операторам. Если нужен был компилятор, оператор своими ногами ходил в
хранилище перфокарт и сам приносил дополнительные наборы перфокарт. Потом
исполнял программы, распечатывал результат и приносил программистам. Времени на
ходьбу туда-сюда тратилось много и это обходилось очень дорого, учитывая
стоимость компьютеров.

Так появилась пакетная обработка. Несколько наборов перфокарт загружались в
один большой лоток и дешёвый маленький компьютер переписывал их на магнитную
ленту. Лента потом физический перегружалась в большой основной компьютер и он
исполнял программы, записывая результаты на другую ленту. Эта лента потом опять
перегружалась в дешёвый компьютер и он распечатывал результаты.

Компьютеры использовались в основном для научных и технических вычислений,
например для решения дифференциальных уравнений в частных производных.

### 1.2.3 Третье поколение (1965-1980): интегральные схемы и многозадачность

Компьютеры этого поколения были собраны уже на интегральных схемах, а не на
отдельных транзисторах, что позволило снизить цены и повысить качество.
Большинство производителей компьютеров имело два вида компьютеров - огромные
дорогостоящие машины с пословной обработкой данных, используемых в науке и
технике, а также маленькие относительно недорогие посимвольные, используемые
банками и страховыми компаниями.

IBM стала первой компанией, выпустившей серию компьютеров. Она была совместима
по программному обеспечению и включала в себя как маленькие недорогие машины,
так и огромные мэйнфреймы. Полноценное программное обеспечение, способное
одинаково хорошо работать как на дешёвом компьютере, так и на дорогом написать,
впрочем, не особо получилось. Но даже то, что получилось, пользовалось
популярностью у клиентов. Была придумана многозадачность. При выполнении
научных расчётов затраты времени на ввод-вывод были небольшими и никого особо
не волновали. Но у коммерческих машин ожидание данных могло занимать до 90%
времени. Чтобы процессор не простаивал, память делилась на разделы, в каждый из
которых помещалось отдельное задание. Если одно из заданий ожидало
ввода-вывода, процессор переключался на другое. Также была придумана подкачка,
когда данные с перфокарт загружались по мере их поступления. Это позволило
отказаться от записи данных на магнитные ленты и обратно.

На этих машинах уже нельзя было выбить себе несколько часов рабочего времени и
править программу прямо во время исполнения. Цикл "отдал программу - получил
результат" мог занимать полдня и если в программе была ошибка, значит
программист потратил время зря.

Так появились системы с разделением времени. У каждого пользователя был
текстовой терминал, в который он мог вводить команды. Т.к. пользователи вводят
эти команды относительно медленно, у центрального процессора обычно есть
достаточно времени чтобы по очереди обслужить все запросы. Это привело к
созданию MULTICS (multiplexed information and computing service).
Предполагалось что сотни программистов могут одновременно использовать один
мэйнфрейм. Она породила много интересных идей, но была не особо коммерчески
успешна.

Также в это время появились мини-компьютеры. Они обладали скромными ресурсами,
но были во много раз дешевле мэйнфреймов. Кен Томпсон, работавший над проектом
MULTICS, решил написать упрощённую версию ОС для мини компьютера, из чего потом
вырос проект UNIX. Из-за широкой доступности исходного кода, разные организации
понаделали своих несовместимых версий UNIX. Для исправления этого институт IEEE
разработал стандарт POSIX, используемый по сей день.

Эндрю Танненбаум разработал в учебных целях маленькую версию UNIX и назвал её
MINIX. А финский студент Линус Торвальдс на её базе сделал свободно
распространяемую ОС Linux.

### 1.2.4 Четвёртое поколение (с 1980 по наши дни): персональные компьютеры

TODO

### 1.2.5 Пятое поколение (с 1990 по наши дни): мобильные компьютеры

TODO

## 1.3 Обзор аппаратного обеспечения компьютера

TODO

### 1.3.1 Процессоры

TODO

### 1.3.2 Многопоточные и многоядерные микропроцессоры

TODO

### 1.3.3 Память

TODO

### 1.3.4 Диски

TODO

### 1.3.5 Устройства ввода-вывода

TODO

### 1.3.6 Шины

TODO

### 1.3.7 Загрузка компьютера

TODO

## 1.4 Зоопарк операционных систем

TODO

### 1.4.1 Операционные системы мейнфреймов

TODO

### 1.4.2 Серверные операционные системы

TODO

### 1.4.3 Многопроцессорные операционные системы

TODO

### 1.4.4 Операционные системы персональных компьютеров

TODO

### 1.4.5 Операционные системы карманных персональных компьютеров

TODO

### 1.4.6 Встроенные операционные системы

TODO

### 1.4.7 Операционные системы сенсорных узлов

TODO

### 1.4.8 Операционные системы реального времени

TODO

### 1.4.9 Операционные системы смарт-карт

TODO

### 1.5 Понятия операционной системы

TODO

### 1.5.1 Процессы

TODO

### 1.5.2 Адресные пространства

TODO

### 1.5.3 Файлы

TODO

### 1.5.4 Ввод-вывод данных

TODO

### 1.5.5 Безопасность

TODO

### 1.5.6 Оболочка

TODO

### 1.5.7 Онтогенез повторяет филогенез

TODO

#### Большие объемы памяти

TODO

#### Аппаратные средства защиты

TODO

#### Диски

TODO

#### Виртуальная память

TODO

### 1.6 Системные вызовы

TODO

### 1.6.1 Системные вызовы для управления процессами

TODO

### 1.6.2 Системные вызовы для управления файлами

TODO

### 1.6.3 Системные вызовы для управления каталогами

TODO

### 1.6.4 Разные системные вызовы

TODO

### 1.6.5 Windows Win32 API

TODO

### 1.7 Структура операционной системы

TODO

### 1.7.1 Монолитные системы

TODO

### 1.7.2 Многоуровневые системы

TODO

### 1.7.3 Микроядра

TODO

### 1.7.4 Клиент-серверная модель

TODO

### 1.7.5 Виртуальные машины

#### VM/370

#### Повторное открытие виртуальных машин

#### Виртуальная машина Java

TODO

### 1.7.6 Экзоядра

TODO

## 1.8 Устройство мира согласно языку С

TODO

### 1.8.1 Язык С

TODO

### 1.8.2 Заголовочные файлы

TODO

### 1.8.3 Большие программные проекты

TODO

### 1.8.4 Модель времени выполнения

TODO

### 1.9 Исследования в области операционных систем

TODO

### 1.10 Краткое содержание остальных глав этой книги

TODO

### 1.11 Единицы измерения

TODO

### 1.12 Краткие выводы

TODO

## Вопросы

TODO
